# The GEB Manual

###### \[in package GEB-DOCS/DOCS\]
Welcome to the GEB project.

## Links



Here is the [official repository](https://github.com/anoma/geb/)

and [HTML documentation](https://anoma.github.io/geb/) for the latest version.



### code coverage



For test coverage it can be found at the following links:

[SBCL test coverage](./tests/cover-index.html)

[CCL test coverage: current under maintenance](./tests/report.html)

---

Note that due to [#34](https://github.com/anoma/geb/issues/34)
CCL tests are not currently displaying

---

I recommend reading the CCL code coverage version, as it has proper tags.

Currently they are manually generated, and thus for a more accurate assessment see GEB-TEST:CODE-COVERAGE



## Getting Started

Welcome to the GEB Project!

### installation

This project uses [common lisp](https://common-lisp.net/), so a few
   dependencies are needed to get around the code-base and start hacking. Namely:

1. [lisp with quicklisp](https://lisp-lang.org/learn/getting-started/).

2. [Emacs](https://en.wikipedia.org/wiki/Emacs) along with one of the following:

    - [sly](https://github.com/joaotavora/sly)

        - [sly user manual](http://joaotavora.github.io/sly/)

    - [slime](https://github.com/slime/slime)

        - [slime user manual](http://www.chiark.greenend.org.uk/doc/slime/slime.pdf)


### loading

Now that we have an environment setup, we can load the project, this
   can be done in a few steps.

1. Open the `REPL` (sbcl (terminal), `M-x` sly, `M-x` swank)

    - For the terminal, this is just calling the [common
       lisp](https://common-lisp.net/) implementation from the
       terminal.

        `user@system:geb-directory % sbcl`.

    - For Emacs, this is simply calling either `M-x sly` or `M-x slime`
       if you are using either [sly](https://github.com/joaotavora/sly) or [slime](https://github.com/slime/slime)

2. From Emacs: open `geb.asd` and press `C-ck` (`sly-compile-and-load-file`, or
   `swank-compile-and-load-file` if you are using swank).

Now that we have the file open, we can now load the system by
writing:

```lisp
;; only necessary for the first time!
(ql:quickload :geb/documentation)

;; if you want to load it in the future
(asdf:load-system :geb/documentation)

;; if you want to load the codbase and run tests at the same time
(asdf:test-system :geb/documentation)

;; if you want to run the tests once the system is loaded!
(geb-test:run-tests)
```


### Geb as a binary

###### \[in package GEB.ENTRY\]
The standard way to use geb currently is by loading the code into
one's lisp environment

```lisp
(ql:quickload :geb)
```

However, one may be interested in running geb in some sort of
compilation process, that is why we also give out a binary for people
to use

An example use of this binary is as follows

```bash
mariari@Gensokyo % ./geb.image -i "foo.lisp" -e "geb.lambda.spec::*entry*" -l -v -o "foo.pir"

mariari@Gensokyo % cat foo.pir
def *entry* x {
  0
}%
mariari@Gensokyo % ./geb.image -i "foo.lisp" -e "geb.lambda.spec::*entry*" -l -v
def *entry* x {
  0
}

./geb.image -h
  -i --input                      string   Input geb file location
  -e --entry-point                string   The function to run, should be fully qualified I.E.
                                           geb::my-main
  -l --stlc                       boolean  Use the simply typed lambda calculus frontend
  -o --output                     string   Save the output to a file rather than printing
  -v --vampir                     string   Return a vamp-ir expression
  -h -? --help                    boolean  The current help message

```

starting from a file *foo.lisp* that has

```lisp
(in-package :geb.lambda.spec)

(defparameter *entry*
  (typed unit geb:so1))
```

inside of it.

The command needs an entry-point (-e or --entry-point), as we are
simply call LOAD on the given file, and need to know what to
translate.

from STLC, we expect the form to be wrapped in the
GEB.LAMBDA.SPEC.TYPED which takes both the type and the value to
properly have enough context to evaluate.

It is advised to bind this to a parameter like in our example as -e
expects a symbol.

the -l flag means that we are not expecting a geb term, but rather a
lambda frontend term, this is to simply notify us to compile it as a
lambda term rather than a geb term. In time this will go away

- [function] COMPILE-DOWN &KEY VAMPIR STLC ENTRY (STREAM \*STANDARD-OUTPUT\*)

## Glossary

- [glossary-term] closed type

    A closed type is a type that can not be extended dynamically.
    A good example of this kind of term is an ML
    [ADT](https://en.wikipedia.org/wiki/Algebraic_data_type).
    
    ```haskell
    data Tree = Empty
              | Leaf Int
              | Node Tree Tree
    ```
    
    In our lisp code we have a very similar convention:
    
    ```lisp
    (in-package :geb.spec)
    
    (deftype substmorph ()
      `(or substobj
           alias
           comp init terminal case pair distribute
           inject-left inject-right
           project-left project-right))
    ```
    
    This type is closed, as only one of GEB:SUBSTOBJ, GEB:INJECT-LEFT,
    GEB:INJECT-RIGHT etc can form the GEB:SUBSTMORPH type.
    
    The main benefit of this form is that we can be exhaustive over what
    can be found in GEB:SUBSTMORPH.
    
    ```lisp
    (defun so-hom-obj (x z)
      (match-of substobj x
        (so0          so1)
        (so1          z)
        (alias        (so-hom-obj (obj x) z))
        ((coprod x y) (prod (so-hom-obj x z)
                            (so-hom-obj y z)))
        ((prod x y)   (so-hom-obj x (so-hom-obj y z)))))
    ```
    
    If we forget a case, like GEB:COPROD it wanrs us with an non exhaustion warning.
    
    Meaning that if we update definitions this works well.
    
    ---
    
    The main downside is that we can not extend the type after the fact,
    meaning that all interfaces on SO-HOM-OBJ must take the unaltered
    type. This is in stark contrast to @OPEN-TYPES. To find out more about
    the trade offs and usage in the code-base read the section @OPEN-CLOSED.

- [glossary-term] open type

    An open type is a type that can be extended by user code down the
    line. A good example of this in ML is the [type class
    system](https://en.wikipedia.org/wiki/Type_class) found in Haskell.
    
    In our code base, it is simple as creating a @CLOS term
    
    ```lisp
    (defclass <substobj> (direct-pointwise-mixin) ())
    ```
    
    and to create a child of it all we need to do is.
    
    ```lisp
    (defclass so0 (<substobj>) ())
    ```
    
    Now any methods on GEB:<SUBSTOBJ> will cover GEB:SO0.
    
    ---
    
    The main disadvantage of these is that exhaustion can not be checked,
    and thus the user has to know what methods to fill out. In a system
    with a bit more checks this is not a problem in practice. To find out
    more about the trade offs and usage in the code-base read the section
    @OPEN-CLOSED.

- [glossary-term] Common Lisp Object System (CLOS)

    The object system found in CL. Has great features like a [Meta Object
    Protocol](http://community.schemewiki.org/?meta-object-protocol) that
    helps it facilitate extensions.

## Original Efforts

Originally GEB started off as an Idris codebase written by the
designer and creator of GEB, Terence Rokop, However further efforts
spawned for even further formal verification by Artem Gureev. Due
to this, we have plenty of code not in Common Lisp that ought to be
a good read.

### Geb's Idris Code

The Idris folder can be found in the
[geb-idris](https://github.com/anoma/geb/tree/main/geb-idris) folder
provided in the codebase

At the time of this document, there is over 16k lines of Idris code
written. This serves as the bulk of the POC that is GEB and is a
treasure trove of interesting information surrounding category
theory.

### Geb's Agda Code

The Agda folder can be found in the
[geb-agda](https://github.com/anoma/geb/tree/main/geb-agda) folder
provided in the codebase

The Agda codebase serves as a great place to view formally verified
properties about the GEB project. Although @IDRIS is written in a
dependently typed language, it serves as reference example of GEB,
while @AGDA serves as the mathematical formalism proving various
conjectures about GEB

## Categorical Model



Geb is organizing programming language concepts (and entities!) using
[category theory](https://plato.stanford.edu/entries/category-theory/),
originally developed by mathematicians,
but very much alive in programming language theory.
Let us look at a simple well-known example:
the category of sets and functions.
It is the bread and butter example:
sets $A,B,C,…$ play the role of *objects*,
functions are *arrows* between objects $A—f→B$,
and the latter *compose* as functions do,
such that every path of matching functions
$$A—f→B—g→C—h→D$$
composes to a corresponding composite function
$$A—f;g;h→D$$ (or $h∘g∘f$ if you prefer)
and we enjoy the luxury of not having to worry about
the order in which we compose;
for the sake of completeness,
there are identify functions $A —\mathrm{id}\_A→ A$ on each set $A$,
serving as identities
(which correspond to the composite of the empty path on an object).
Sets and functions *together* form **a** category—based on
function composition;
thus, let's call this category *sets-'n'-functions*.
This example,
even “restricted” to  *finite sets-'n'-functions*,
will permeate through Geb.
<!--
although the “weird” habit of avoiding
talk about elements of sets as much as possible.
-->

One of the first lessons (in any introduction to category theory)
about *sets-'n'-functions* is the characterization of
[product](https://en.wikipedia.org/wiki/Product_(category_theory)#Product_of_two_objects)s
and [disjoint sum](https://en.wikipedia.org/wiki/Coproduct#Definition)s of sets
in terms of functions alone,
i.e.,
**without *ever* talking about elements of sets**.
Products and co-products are the simplest examples of
*universal constructions*.
One of the first surprises follows suit
when we generalize functions to partial functions,
relations, or even multi-relations:
*we obtain **very** different categories!*
For example,
in the category [*sets-'n'-relations*](https://en.wikipedia.org/wiki/Category_of_relations),
the disjoint union of sets features as both a product and a co-product,
as a categorical construction.

*Do not fear!*
The usual definition of products in terms of elements of sets are
absolutely compatible with the
universal construction in *sets-'n'-functions*.
However we gain the possibility
to compare the “result” of the  *universal constructions*
in *sets-'n'-functions* with the one in *sets-'n'-relations*
(as both actually do have products).

for the purposes of Geb,
many things can be expressed in analogy to
the category of *sets-'n'-functions*;
thus a solid understanding of the latter
will be quite useful.
In particular,
we shall rely on the following
universal constructions:

1. The construction of binary products $A × B$ of sets $A,B$, and the empty product $\mathsf{1}$.

2. The construction of “function spaces” $B^A$ of sets $A,B$, called *exponentials*,
   i.e., collections of functions between pairs of sets.

3. The so-called [*currying*](https://en.wikipedia.org/wiki/Currying)
of functions,
   $C^{(B^A)} \cong C^{(A × B)}$,
   such that providing several arguments to a function can done
   either simultaneously, or in sequence.

4. The construction of sums (a.k.a.  co-products) $A + B$ of sets $A,B$,
   corresponding to forming disjoint unions of sets;
   the empty sum is $\varnothing$.

Product, sums and exponentials
are the (almost) complete tool chest for writing
polynomial expressions, e.g.,
$$Ax^{\sf 2} +x^{\sf 1} - Dx^{\sf 0}.$$
(We need these later to define [“algebraic data types”](https://en.wikipedia.org/wiki/Polynomial_functor_(type_theory)).)
In the above expression,
we have sets instead of numbers/constants
where $ \mathsf{2} = \lbrace 1, 2 \rbrace$,
$ \mathsf{1} = \lbrace 1 \rbrace$,
$ \mathsf{0} = \lbrace  \rbrace = \varnothing$,
and $A$ and $B$ are arbitrary (finite) sets.
We are only missing a counterpart for the *variable*!
Raising an arbitrary set to “the power” of a constant set
happens to have a very natural counterpart:
the central actor of
[the most-well known fundamental result about categories](https://en.wikipedia.org/wiki/Yoneda_lemma),
which generalizes Cayley's Theorem, i.e., the [Yoneda embedding](https://en.wikipedia.org/wiki/Yoneda_lemma#The_Yoneda_embedding).

If you are familiar with the latter,
buckle up and jump to @POLY-SETS.
Have a look at our streamlined account of @YONEDA-LEMMA
if you are familiar with Cartesian closed categories,
or take it slow and read up on the background in
one of the classic or popular
[textbooks](https://www.goodreads.com/shelf/show/category-theory).
Tastes tend to vary.
However,
Benjamin Pierce's
[*Basic Category Theory for Computer Scientists*](https://mitpress.mit.edu/9780262660716/) deserves being pointed out
as it is very amenable *and*
covers the background we need in 60 short pages.



### Morphisms


### Objects


### The Yoneda Lemma


### Poly in Sets


## Project Idioms and Conventions

The Geb Project is written in [Common
Lisp](https://common-lisp.net/), which means the authors have a great
choice in freedom in how the project is laid out and operates. In
particular the style of [Common Lisp](https://common-lisp.net/) here
is a
[functional](https://en.wikipedia.org/wiki/Functional_programming)
style with some
[OO](https://en.wikipedia.org/wiki/Object-oriented_programming) idioms
in the style of [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk).

The subsections will outline many idioms that can be found throughout
the codebase.

### Spec Files and Project Layout

###### \[in package GEB.SPECS\]
The codebase is split between many files. Each folder can be seen as
a different idea within geb itself! Thus the `poly` has packages
revolving around polynomials, the `geb` folder has packages regarding
the main types of geb GEB.SPEC:@GEB-SUBSTMU and
GEB.SPEC:@GEB-SUBSTMORPH, etc etc.

The general layout quirk of the codebase is that packages like
`geb.package.spec` defines the specification for the base types for
any category we wish to model, and these reside in the `specs` folder
not in the folder that talks about the packages of those types. This
is due to loading order issues, we thus load the `specs` packages
before each of their surrounding packages, so that each package can
build off the last.

Further to make working with each package of an
idea easy, we have the main package of the folder (typically named the
same as the folder name) rexport their specifications so if one wants
to work with the fully fledged versions of the package they can simply
without having to import too many packages at once.

For example, the `geb.poly.spec` defines out the types and data
structures of the GEB.POLY.SPEC:@POLY-MANUAL, this is then rexported
in `geb.poly`, giving the module `geb.poly` a convenient interface for
all functions that operate on `geb.poly`.

### Open Types versus Closed Types

@CLOSED-TYPE's and @OPEN-TYPE's both have their perspective
tradeoff of openness versus exhaustiveness (see the linked articles
for more on that). Due to this, they both have their own favorable
applications. I would argue that a closed
[ADT](https://en.wikipedia.org/wiki/Algebraic_data_type) type is great
tool for looking at a function mathematically and treating the object
as a whole rather than piecemeal. Whereas a more open extension is
great for thinking about how a particular object/case behaves. They
are different mindsets for different styles of code.

In the geb project, we have chosen to accept both styles, and allow
both to coexist in the same setting. We have done this with a two part
idiom.

```lisp
(deftype substobj ()
  `(or alias prod coprod so0 so1))

(defclass <substobj> (direct-pointwise-mixin) ())

(defclass so0 (<substobj>) ...)

(defclass prod (<substobj>) ...)
```

The @CLOSED-TYPE is GEB:SUBSTOBJ, filling and defining every structure
it knows about. This is a fixed idea that a programmer may statically
update and get exhaustive warnings about. Whereas GEB:<SUBSTOBJ> is
the open interface for the type. Thus we can view GEB:<SUBSTOBJ> as
the general idea of a GEB:SUBSTOBJ. Before delving into how we combine
these methods, let us look at two other benefits given by GEB:<SUBSTOBJ>

1. We can put all the @MIXINS into the superclass to enforce that any
   type that extends it has the extended behaviors we wish. This is a
   great way to generically enhance the capabilities of the type
   without operating on it directly.

2. We can dispatch on GEB:<SUBSTOBJ> since DEFMETHOD only works on
   @CLOS types and not generic types in CL.

#### Methods for closed and open types

With these pieces in play let us explore how we write a method in a
way that is conducive to open and closed code.

```lisp
(in-package :geb)

(defgeneric to-poly (morphism))

(defmethod to-poly ((obj <substmorph>))
  (typecase-of substmorph obj
    (alias        ...)
    (substobj     (error "Impossible")
    (init          0)
    (terminal      0)
    (inject-left   poly:ident)
    (inject-right  ...)
    (comp          ...)
    (case          ...)
    (pair          ...)
    (project-right ...)
    (project-left  ...)
    (distribute    ...)
    (otherwise (subclass-responsibility obj))))

(defmethod to-poly ((obj <substobj>))
  (declare (ignore obj))
  poly:ident)
```

In this piece of code we can notice a few things:

1. We case on GEB:SUBSTMORPH exhaustively

2. We cannot hit the GEB:<SUBSTOBJ> case due to method dispatch

3. We have this GEB.UTILS:SUBCLASS-RESPONSIBILITY function getting called.

4. We can write further methods extending the function to other subtypes.

Thus the GEB:TO-POLY function is written in such a way that it
supports a closed definition and open extensions, with
GEB.UTILS:SUBCLASS-RESPONSIBILITY serving to be called if an
extension a user wrote has no handling of this method.

Code can also be naturally written in a more open way as well, by
simply running methods on each class instead.

#### Potential Drawback and Fixes

One nasty drawback is that we can't guarantee the method exists. In
java this can easily be done with interfaces and then enforcing they
are fulfilled. Sadly CL has no such equivalent. However, this is all
easily implementable. If this ever becomes a major problem, it is
trivial to implement this by registering the subclasses, and the
perspective methods, and scouring the image for instance methods, and
computing if any parent class that isn't the one calling
responsibility fulfills it. Thus, in practice, you should be able to
ask the system if any particular extension fulfills what extension
sets that the base object has and give CI errors if they are not
fulfilled, thus enforcing closed behavior when warranted.

### ≺Types≻

These refer to the @OPEN-TYPE variant to a @CLOSED-TYPE. Thus when
one sees a type like GEB:<SUBSTOBJ> it is the open version of
GEB:SUBSTOBJ. Read @OPEN-CLOSED for information on how to use them.

## The Geb Model

###### \[in package GEB\]
Everything here relates directly to the underlying machinery of
GEB, or to abstractions that help extend it.

### Core Category

###### \[in package GEB.SPEC\]
The underlying category of GEB. With @GEB-SUBSTMU covering the
shapes and forms (GEB-DOCS/DOCS:@OBJECTS) of data while @GEB-SUBSTMORPH
deals with concrete GEB-DOCS/DOCS:@MORPHISMS within the category.

From this category, most abstractions will be made, with
SUBSTOBJ serving as a concrete type layout, with
SUBSTMORPH serving as the morphisms between different
SUBSTOBJ types. This category is equivalent to
[finset](https://ncatlab.org/nlab/show/FinSet).

A good example of this category at work can be found within the
GEB-BOOL::@GEB-BOOL section.

#### Subst Obj

This section covers the objects of the SUBSTMORPH
category. Note that SUBSTOBJ refers to the
GEB-DOCS/DOCS:@CLOSED-TYPE, whereas <SUBSTOBJ> refers
to the GEB-DOCS/DOCS:@OPEN-TYPE that allows for user extension.

- [type] SUBSTOBJ

- [type] <SUBSTOBJ>

    the class corresponding to SUBSTOBJ. See GEB-DOCS/DOCS:@OPEN-CLOSED

SUBSTOBJ type is not a constructor itself, instead it's
best viewed as the sum type, with the types below forming the
constructors for the term. In ML we would write it similarly to:

```haskell
type substobj = so0
              | so1
              | prod
              | coprod
```


- [type] PROD

    The PRODUCT object. Takes two <SUBSTOBJ> values that
    get put into a pair.
    
    The formal grammar of PRODUCT is
    
    ```lisp
    (prod mcar mcadr)
    ```
    
    where PROD is the constructor, MCAR is the left value of the
    product, and MCADR is the right value of the product.
    
    Example:
    
    ```lisp
    (geb-gui::visualize (prod geb-bool:bool geb-bool:bool))
    ```
    
    Here we create a product of two GEB-BOOL:BOOL types.

- [type] COPROD

    the CO-PRODUCT object. Takes <SUBSTOBJ> values that
    get put into a choice of either value.
    
    The formal grammar of PRODUCT is
    
    ```lisp
    (coprod mcar mcadr)
    ```
    
    Where CORPOD is the constructor, MCAR is the left choice of
    the sum, and MCADR is the right choice of the sum.
    
    Example:
    
    ```lisp
    (geb-gui::visualize (coprod so1 so1))
    ```
    
    Here we create the boolean type, having a choice between two unit
    values.

- [type] SO0

    The Initial Object. This is sometimes known as the
    [VOID](https://en.wikipedia.org/wiki/Void_type) type.
    
    the formal grammar of SO0 is
    
    ```lisp
    so0
    ```
    
    where SO0 is `THE` initial object.
    
    Example
    
    `lisp
    `

- [type] SO1

    The Terminal Object. This is sometimes referred to as the
    [Unit](https://en.wikipedia.org/wiki/Unit_type) type.
    
    the formal grammar or SO1 is
    
    ```lisp
    so1
    ```
    
    where SO1 is `THE` terminal object
    
    Example
    
    ```lisp
    (coprod so1 so1)
    ```
    
    Here we construct GEB-BOOL:BOOL by simply stating that we have the
    terminal object on either side, giving us two possible ways to fill
    the type.
    
    ```lisp
    (->left so1 so1)
    
    (->right so1 so1)
    ```
    
    where applying ->LEFT gives us the left unit, while ->RIGHT gives
    us the right unit.

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMU

- [method] MCAR (PROD PROD)

- [method] MCADR (PROD PROD)

- [method] MCAR (COPROD COPROD)

- [method] MCADR (COPROD COPROD)

#### Subst Morph

The overarching types that categorizes the SUBSTMORPH
category. Note that SUBSTMORPH refers to the
GEB-DOCS/DOCS:@CLOSED-TYPE, whereas <SUBSTMORPH> refers
to the GEB-DOCS/DOCS:@OPEN-TYPE that allows for user extension.

- [type] SUBSTMORPH

    The morphisms of the SUBSTMORPH category

- [type] <SUBSTMORPH>

    the class type corresponding to SUBSTMORPH. See GEB-DOCS/DOCS:@OPEN-CLOSED

SUBSTMORPH type is not a constructor itself, instead it's
best viewed as the sum type, with the types below forming the
constructors for the term. In ML we would write it similarly to:

```haskell
type substmorph = comp
                | substobj
                | case
                | init
                | terminal
                | pair
                | distribute
                | inject-left
                | inject-right
                | project-left
                | project-right
```

Note that an instance of SUBSTOBJ, acts like the identity
morphism to the layout specified by the given SUBSTOBJ. Thus
we can view this as automatically lifting a SUBSTOBJ into a
SUBSTMORPH

- [type] COMP

    The composition morphism. Takes two <SUBSTMORPH> values that get
    applied in standard composition order.
    
    The formal grammar of COMP is
    
    ```lisp
    (comp mcar mcadr)
    ```
    
    which may be more familiar as
    
    ```haskell
    g 。f
    ```
    
    Where COMP( 。) is the constructor, MCAR(g) is the second morphism
    that gets applied, and MCADR(f) is the first morphism that gets
    applied.
    
    Example:
    
    ```lisp
    (geb-gui::visualize
     (comp
      (<-right so1 geb-bool:bool)
      (pair (<-left so1 geb-bool:bool)
            (<-right so1 geb-bool:bool))))
    ```
    
    In this example we are composing two morphisms. the first morphism
    that gets applied (PAIR ...) is the identity function on the
    type (PROD SO1 GEB-BOOL:BOOL), where we pair the
    [left projection](PROJECT-LEFT) and the [right
    projection](PROJECT-RIGHT), followed by taking the [right
    projection](PROJECT-RIGHT) of the type.
    
    Since we know (COMP f id) is just f per the laws of category
    theory, this expression just reduces to
    
    ```lisp
    (<-right so1 geb-bool:bool)
    ```


- [type] CASE

    Eliminates coproducts. Namely Takes two <SUBSTMORPH> values, one
    gets applied on the left coproduct while the other gets applied on the
    right coproduct. The result of each <SUBSTMORPH> values must be
    the same.
    
    The formal grammar of CASE is:
    
    ```lisp
    (mcase mcar mcadr)
    ```
    
    Where MCASE is the constructor, MCAR is the morphism that gets
    applied to the left coproduct, and MCADR is the morphism that gets
    applied to the right coproduct.
    
    Example:
    
    ```lisp
    (comp
     (mcase geb-bool:true
            geb-bool:not)
     (->right so1 geb-bool:bool))
    ```
    
    In the second example, we inject a term with the shape GEB-BOOL:BOOL
    into a pair with the shape (SO1 × GEB-BOOL:BOOL), then we use
    MCASE to denote a morphism saying. IF the input is of the shape SO1,
    then give us True, otherwise flip the value of the boolean coming in.

- [type] INIT

    The INITIAL Morphism, takes any <SUBSTOBJ> and
    creates a moprhism from SO0 (also known as void) to the object given.
    
    The formal grammar of INITIAL is
    
    ```lisp
    (init obj)
    ```
    
    where INIT is the constructor. OBJ is the type of object
    that will be conjured up from SO0, when the morphism is
    applied onto an object.
    
    Example:
    
    ```lisp
    (init so1)
    ```
    
    In this example we are creating a unit value out of void.

- [type] TERMINAL

    The TERMINAL morphism, Takes any <SUBSTOBJ> and creates a
    morphism from that object to SO1 (also known as unit).
    
    The formal grammar of TERMINAL is
    
    ```lisp
    (terminal obj)
    ```
    
    where TERMINAL is the constructor. OBJ is the type of object that
    will be mapped to SO1, when the morphism is applied onto an
    object.
    
    Example:
    
    ```lisp
    (terminal (coprod so1 so1))
    
    (geb-gui::visualize (terminal (coprod so1 so1)))
    
    (comp value (terminal (codomain value)))
    
    (comp true (terminal bool))
    ```
    
    In the first example, we make a morphism from the corpoduct of
    SO1 and SO1 (essentially GEB-BOOL:BOOL) to
    SO1.
    
    In the third example we can proclaim a constant function by ignoring
    the input value and returning a morphism from unit to the desired type.
    
    The fourth example is taking a GEB-BOOL:BOOL and returning GEB-BOOL:TRUE.

- [type] PAIR

    Introduces products. Namely Takes two <SUBSTMORPH> values. When
    the PAIR morphism is applied on data, these two <SUBSTMORPH>'s are
    applied to the object, returning a pair of the results
    
    The formal grammar of constructing an instance of pair is:
    
    ```
    (pair mcar mcdr)
    ```
    
    where PAIR is the constructor, MCAR is the left morphism, and MCDR is
    the right morphism
    
    Example:
    
    ```lisp
    (pair (<-left so1 geb-bool:bool)
          (<-right so1 geb-bool:bool))
    
    (geb-gui::visualize (pair (<-left so1 geb-bool:bool)
                              (<-right so1 geb-bool:bool)))
    ```
    
    Here this pair morphism takes the pair SO1 × GEB-BOOL:BOOL, and
    projects back the left field SO1 as the first value of the pair and
    projects back the GEB-BOOL:BOOL field as the second values.

- [type] DISTRIBUTE

    The distributive law

- [type] INJECT-LEFT

    The left injection morphism. Takes two <SUBSTOBJ> values. It is
    the dual of INJECT-RIGHT
    
    The formal grammar is
    
    ```lisp
    (->left mcar mcadr)
    ```
    
    Where ->LEFT is the constructor, MCAR is the value being injected into
    the coproduct of MCAR + MCADR, and the MCADR is just the type for
    the unused right constructor.
    
    Example:
    
    ```lisp
    (geb-gui::visualize (->left so1 geb-bool:bool))
    
    (comp
     (mcase geb-bool:true
            geb-bool:not)
     (->left so1 geb-bool:bool))
    
    ```
    
    In the second example, we inject a term with the shape SO1 into a pair
    with the shape (SO1 × GEB-BOOL:BOOL), then we use MCASE to denote a
    morphism saying. `IF` the input is of the shape SO1, then give us True,
    otherwise flip the value of the boolean coming in.

- [type] INJECT-RIGHT

    The right injection morphism. Takes two <SUBSTOBJ> values. It is
    the dual of INJECT-LEFT
    
    The formal grammar is
    
    ```lisp
    (->right mcar mcadr)
    ```
    
    Where ->RIGHT is the constructor, MCADR is the value being injected into
    the coproduct of MCAR + MCADR, and the MCAR is just the type for
    the unused left constructor.
    
    Example:
    
    ```lisp
    (geb-gui::visualize (->right so1 geb-bool:bool))
    
    (comp
     (mcase geb-bool:true
            geb-bool:not)
     (->right so1 geb-bool:bool))
    
    ```
    
    In the second example, we inject a term with the shape GEB-BOOL:BOOL
    into a pair with the shape (SO1 × GEB-BOOL:BOOL), then we use
    MCASE to denote a morphism saying. IF the input is of the shape SO1,
    then give us True, otherwise flip the value of the boolean coming in.

- [type] PROJECT-LEFT

    The LEFT PROJECTION. Takes two
    <SUBSTMORPH> values. When the LEFT PROJECTION morphism is then applied, it grabs the left value of a product,
    with the type of the product being determined by the two
    <SUBSTMORPH> values given.
    
    the formal grammar of a PROJECT-LEFT is:
    
    ```lisp
    (<-left mcar mcadr)
    ```
    
    Where <-LEFT is the constructor, MCAR is the left type of the
    PRODUCT and MCADR is the right type of the PRODUCT.
    
    Example:
    
    ```lisp
    (geb-gui::visualize
      (<-left geb-bool:bool (prod so1 geb-bool:bool)))
    ```
    
    In this example, we are getting the left GEB-BOOL:BOOL from a
    product with the shape
    
    (GEB-BOOL:BOOL × SO1 × GEB-BOOL:BOOL)

- [type] PROJECT-RIGHT

    The RIGHT PROJECTION. Takes two
    <SUBSTMORPH> values. When the RIGHT PROJECTION morphism is then applied, it grabs the right value of a product,
    with the type of the product being determined by the two
    <SUBSTMORPH> values given.
    
    the formal grammar of a PROJECT-RIGHT is:
    
    ```lisp
    (<-right mcar mcadr)
    ```
    
    Where <-RIGHT is the constructor, MCAR is the right type of the
    PRODUCT and MCADR is the right type of the PRODUCT.
    
    Example:
    
    ```lisp
    (geb-gui::visualize
     (comp (<-right so1 geb-bool:bool)
           (<-right geb-bool:bool (prod so1 geb-bool:bool))))
    ```
    
    In this example, we are getting the right GEB-BOOL:BOOL from a
    product with the shape
    
    (GEB-BOOL:BOOL × SO1 × GEB-BOOL:BOOL)

- [type] FUNCTOR

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMORPH

- [method] MCAR (COMP COMP)

    The first composed morphism

- [method] MCADR (COMP COMP)

    the second morphism

- [method] OBJ (INIT INIT)

- [method] OBJ (INIT INIT)

- [method] MCAR (CASE CASE)

    The morphism that gets applied on the left coproduct

- [method] MCADR (CASE CASE)

    The morphism that gets applied on the right coproduct

- [method] MCAR (PAIR PAIR)

    The left morphism

- [method] MCDR (PAIR PAIR)

    The right morphism

- [method] MCAR (DISTRIBUTE DISTRIBUTE)

- [method] MCADR (DISTRIBUTE DISTRIBUTE)

- [method] MCADDR (DISTRIBUTE DISTRIBUTE)

- [method] MCAR (INJECT-LEFT INJECT-LEFT)

- [method] MCADR (INJECT-LEFT INJECT-LEFT)

- [method] MCAR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCADR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCAR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCADR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCAR (PROJECT-RIGHT PROJECT-RIGHT)

- [method] MCADR (PROJECT-RIGHT PROJECT-RIGHT)

    Right projection (product elimination)

### Accessors

###### \[in package GEB.UTILS\]
These functions are generic lenses of the GEB codebase. If a class is
defined, where the names are not known, then these accessors are
likely to be used. They may even augment existing classes.

- [generic-function] MCAR OBJ

    Can be seen as calling CAR on a generic CLOS
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] MCADR OBJ

    like MCAR but for the CADR

- [generic-function] MCADDR OBJ

    like MCAR but for the CADDR

- [generic-function] MCADDDR OBJ

    like MCAR but for the CADDDR

- [generic-function] MCDR OBJ

    Similar to MCAR, however acts like a CDR for
    classes that we wish to view as a SEQUENCE

- [generic-function] OBJ OBJ

    Grabs the underlying
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] NAME OBJ

    the name of the given
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] FUNC OBJ

    the function of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] PREDICATE OBJ

    the PREDICATE of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] THEN OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] ELSE OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

### Constructors

###### \[in package GEB.SPEC\]
The API for creating GEB terms. All the functions and variables
here relate to instantiating a term

- [variable] *SO0* s-0

    The Initial Object

- [variable] *SO1* s-1

    The Terminal Object

More Ergonomic API variants for *SO0* and *SO1*

- [symbol-macro] SO0

- [symbol-macro] SO1

- [function] MAKE-ALIAS &KEY NAME OBJ

- [function] <-LEFT MCAR MCADR

    projects left constructor

- [function] <-RIGHT MCAR MCADR

    projects right constructor

- [function] ->LEFT MCAR MCADR

    injects left constructor

- [function] ->RIGHT MCAR MCADR

    injects right constructor

- [function] MCASE MCAR MCADR

- [function] MAKE-FUNCTOR &KEY OBJ FUNC

### API

Various forms and structures built on-top of @GEB-CATEGORIES

#### Booleans

###### \[in package GEB-BOOL\]
Here we define out the idea of a boolean. It comes naturally from the
concept of coproducts. In ML they often define a boolean like

```haskell
data Bool = False | True
```

We likewise define it with coproducts

```lisp
(def bool (coprod so1 so1))

(def true  (->right so1 so1))
(def false (->left  so1 so1))
```

The functions given work on this.

- [symbol-macro] TRUE

    The true value of a boolean type. In this case we've defined true as
    the right unit

- [symbol-macro] FALSE

    The false value of a boolean type. In this case we've defined true as
    the left unit

- [symbol-macro] BOOL

    The Boolean Type, composed of a coproduct of two unit objects
    
    ```lisp
    (coprod so1 so1)
    ```


- [symbol-macro] NOT

    Turns a TRUE into a FALSE and vice versa

- [symbol-macro] AND

- [symbol-macro] OR

#### Translation Functions

###### \[in package GEB.TRANS\]
These cover various conversions from @GEB-SUBSTMORPH and @GEB-SUBSTMU
into other categorical data structures.

- [generic-function] TO-POLY MORPHISM

    Turns a @GEB-SUBSTMORPH into a POLY:POLY

#### Utility

Various utility functions ontop of @GEB-CATEGORIES

- [function] PAIR-TO-LIST PAIR &OPTIONAL ACC

    converts excess pairs to a list format

- [function] SAME-TYPE-TO-LIST PAIR TYPE &OPTIONAL ACC

    converts the given type to a list format

- [function] CLEAVE V1 &REST VALUES

    Applies each morphism to the object in turn.

- [function] CONST F X

    The constant morphism.
    
    Takes a morphism from SO1 to a desired value of type $B$,
    along with a <SUBSTOBJ> that represents the input type say of
    type $A$, giving us a morphism from $A$ to $B$.
    
    Thus if:
    F : SO1 → a,
    X : b
    
    then: (const f x) : a → b
    
    ```
    Γ, f : so1 → b, x : a
    ----------------------
    (const f x) : a → b
    ```
    
    Further, If the input `F` is an ALIAS, then we wrap the output
    in a new alias to denote it's a constant version of that value.
    
    Example:
    
    ```lisp
    (const true bool) ; bool -> bool
    ```


- [function] COMMUTES X Y

- [function] COMMUTES-LEFT MORPH

    swap the input domain of the given <SUBSTMORPH>
    
    In order to swap the domain we expect the <SUBSTMORPH> to
    be a PROD
    
    Thus if: `(dom morph) ≡ (prod x y)`, for any `x`, `y` <SUBSTOBJ>
    
    then: `(commutes-left (dom morph)) ≡ (prod y x)`
    
    ```
    Γ, f : x × y → a
    ------------------------------
    (commutes-left f) : y × x → a
    ```


- [function] !-> A B

- [function] SO-EVAL X Y

- [generic-function] SO-CARD-ALG OBJ

    Gets the cardinality of the given object, returns a FIXNUM

- [method] SO-CARD-ALG (OBJ \<SUBSTOBJ\>)

- [generic-function] DOM SUBSTMORPH

    Grabs the domain of the morphism. Returns a <SUBSTOBJ>

- [generic-function] CODOM SUBSTMORPH

    Grabs the codomain of the morphism. Returns a <SUBSTOBJ>

- [generic-function] CURRY F

    Curries the given object, returns a <SUBSTMORPH>
    
    The <SUBSTMORPH> given must have its DOM be of a PROD type, as CURRY
    invokes the idea of
    
    if f : (PROD a b) → c
    
    for all `a`, `b`, and `c` being an element of <SUBSTMORPH>
    
    then: (curry f): a → c^b
    
    where c^b means c to the exponent of b (EXPT c b)
    
    ```
    Γ, f : a × b → c,
    --------------------
    (curry f) : a → c^b
    ```
    
    In category terms, `a → c^b` is isomorphic to `a → b → c`


### Examples

PLACEHOLDER: TO SHOW OTHERS HOW EXAMPLES WORK

Let's see the transcript of a real session of someone working
with GEB:

```common-lisp
(values (princ :hello) (list 1 2))
.. HELLO
=> :HELLO
=> (1 2)

(+ 1 2 3 4)
=> 10
```


## Polynomial Specification

###### \[in package GEB.POLY.SPEC\]
This covers a GEB view of Polynomials. In particular this type will
be used in translating GEB's view of Polynomials into Vampir

### Polynomial Types

This section covers the types of things one can find in the POLY
constructors

- [type] POLY

- [type] <POLY>

- [type] IDENT

    The Identity Element

- [type] +

- [type] *

- [type] /

- [type] -

- [type] MOD

- [type] COMPOSE

- [type] IF-ZERO

    compare with zero: equal takes first branch;
    not-equal takes second branch

- [type] IF-LT

    If the MCAR argument is strictly less than the MCADR then the
    THEN branch is taken, otherwise the ELSE branch is taken.

### Polynomial Constructors

Every accessor for each of the CLASS's found here are from @GEB-ACCESSORS

- [symbol-macro] IDENT

- [function] + MCAR MCADR &REST ARGS

    Creates a multiway constructor for +

- [function] * MCAR MCADR &REST ARGS

    Creates a multiway constructor for \*

- [function] / MCAR MCADR &REST ARGS

    Creates a multiway constructor for /

- [function] - MCAR MCADR &REST ARGS

    Creates a multiway constructor for -

- [function] MOD MCAR MCADR

    MOD ARG1 by ARG2

- [function] COMPOSE MCAR MCADR &REST ARGS

    Creates a multiway constructor for COMPOSE

- [function] IF-ZERO PRED THEN ELSE

    checks if PREDICATE is zero then take the THEN branch otherwise the ELSE branch

- [function] IF-LT MCAR MCADR THEN ELSE

    Checks if the MCAR is less than the MCADR and chooses the appropriate branch

## The Simply Typed Lambda Calculus model

###### \[in package GEB.LAMBDA\]
This covers GEB's view on simply typed lambda calculus

### Lambda Specification

###### \[in package GEB.LAMBDA.SPEC\]
This covers the various the abstract data type that is the simply
  typed lambda calculus within GEB.

The specification follows from the sum type declaration

```lisp
(defunion stlc
  (absurd (value t))
  unit
  (left (value t))
  (right (value t))
  (case-on (lty geb.spec:substmorph)
           (rty geb.spec:substmorph)
           (cod geb.spec:substmorph)
           (on t) (left t) (right t))
  (pair (lty geb.spec:substmorph) (rty geb.spec:substmorph) (left t) (right t))
  (fst  (lty geb.spec:substmorph) (rty geb.spec:substmorph) (value t))
  (snd  (lty geb.spec:substmorph) (rty geb.spec:substmorph) (value t))
  (lamb (vty geb.spec:substmorph) (tty geb.spec:substmorph) (value t))
  (app  (dom geb.spec:substmorph) (cod geb.spec:substmorph) (func t) (obj t))
  (index (index fixnum)))
```


- [type] <STLC>

- [type] STLC

- [type] ABSURD

- [function] ABSURD-VALUE INSTANCE

- [type] UNIT

- [type] PAIR

- [function] PAIR-LTY INSTANCE

- [function] PAIR-RTY INSTANCE

- [function] PAIR-LEFT INSTANCE

- [function] PAIR-RIGHT INSTANCE

- [type] LEFT

- [function] LEFT-VALUE INSTANCE

- [type] RIGHT

- [function] RIGHT-VALUE INSTANCE

- [type] CASE-ON

- [function] CASE-ON-LTY INSTANCE

- [function] CASE-ON-RTY INSTANCE

- [function] CASE-ON-COD INSTANCE

- [function] CASE-ON-ON INSTANCE

- [function] CASE-ON-LEFT INSTANCE

- [function] CASE-ON-RIGHT INSTANCE

- [type] FST

- [function] FST-LTY INSTANCE

- [function] FST-RTY INSTANCE

- [function] FST-VALUE INSTANCE

- [type] SND

- [function] SND-LTY INSTANCE

- [function] SND-RTY INSTANCE

- [function] SND-VALUE INSTANCE

- [type] LAMB

- [function] LAMB-VTY INSTANCE

- [function] LAMB-TTY INSTANCE

- [function] LAMB-VALUE INSTANCE

- [type] APP

- [function] APP-DOM INSTANCE

- [function] APP-COD INSTANCE

- [function] APP-FUNC INSTANCE

- [function] APP-OBJ INSTANCE

- [type] INDEX

- [function] INDEX-INDEX INSTANCE

- [function] TYPED V TYP

    Puts together the type declaration with the value itself for lambda terms

- [function] TYPED-STLC-TYPE INSTANCE

- [function] TYPED-STLC-VALUE INSTANCE

### Transition Functions

###### \[in package GEB.LAMBDA.TRANS\]
These functions deal with transforming the data structure to other
data types

- [generic-function] COMPILE-CHECKED-TERM CONTEXT TYPE TERM

    Compiles a checked term into SubstMorph category

#### Utility Functionality

These are utility functions relating to translating lambda terms to other types

- [function] STLC-CTX-TO-MU CONTEXT

    Converts a generic <STLC> context into a SUBSTMORPH

## Mixins

###### \[in package GEB.MIXINS\]
Various [mixins](https://en.wikipedia.org/wiki/Mixin) of the
project. Overall all these offer various services to the rest of the
project

### Pointwise Mixins

Here we provide various mixins that deal with classes in a pointwise
manner. Normally, objects can not be compared in a pointwise manner,
instead instances are compared. This makes functional idioms like
updating a slot in a pure manner (allocating a new object), or even
checking if two objects are `EQUAL`-able adhoc. The pointwise API,
however, derives the behavior and naturally allows such idioms

- [class] POINTWISE-MIXIN

    Provides the service of giving point wise
    operations to classes

Further we may wish to hide any values inherited from our superclass
due to this we can instead compare only the slots defined directly
in our class

- [class] DIRECT-POINTWISE-MIXIN POINTWISE-MIXIN

    Works like POINTWISE-MIXIN, however functions on
    POINTWISE-MIXIN will only operate on direct-slots
    instead of all slots the class may contain.
    
    Further all `DIRECT-POINTWISE-MIXIN`'s are POINTWISE-MIXIN's

### Pointwise API

These are the general API functions on any class that have the
POINTWISE-MIXIN service.

Functions like TO-POINTWISE-LIST allow generic list traversal APIs to
be built off the key-value pair of the raw object form, while
OBJ-EQUALP allows the checking of functional equality between
objects. Overall the API is focused on allowing more generic
operations on classes that make them as useful for generic data
traversal as `LIST`'s are

- [generic-function] TO-POINTWISE-LIST OBJ

    Turns a given object into a pointwise LIST. listing
    the KEYWORD slot-name next to their value.

- [generic-function] OBJ-EQUALP OBJECT1 OBJECT2

    Compares objects with pointwise equality. This is a
    much weaker form of equality comparison than
    STANDARD-OBJECT EQUALP, which does the much
    stronger pointer quality

- [generic-function] POINTWISE-SLOTS OBJ

    Works like C2MOP:COMPUTE-SLOTS however on the object
    rather than the class

### Mixins Examples

Let's see some example uses of POINTWISE-MIXIN:

```common-lisp
(obj-equalp (geb:terminal geb:so1)
            (geb:terminal geb:so1))
=> t

(to-pointwise-list (geb:coprod geb:so1 geb:so1))
=> ((:MCAR . s-1) (:MCADR . s-1))
```


## Geb Utilities

###### \[in package GEB.UTILS\]
The Utilities package provides general utility functionality that is
used throughout the GEB codebase

- [type] LIST-OF TY

    Allows us to state a list contains a given type.
    
    ---
    
    *NOTE*
    
    This does not type check the whole list, but only the first
    element. This is an issue with how lists are defined in the
    language. Thus this should be be used for intent purposes.
    
    ---
    
    For a more proper version that checks all elements please look at writing code like
    
    ```cl
    (deftype normal-form-list ()
      `(satisfies normal-form-list))
    
    (defun normal-form-list (list)
      (and (listp list)
           (every (lambda (x) (typep x 'normal-form)) list)))
    
    (deftype normal-form ()
      `(or wire constant))
    ```
    
    Example usage of this can be used with `typep`
    
    ```common-lisp
    (typep '(1 . 23) '(list-of fixnum))
    => NIL
    
    (typep '(1 23) '(list-of fixnum))
    => T
    
    (typep '(1 3 4 "hi" 23) '(list-of fixnum))
    => T
    
    (typep '(1 23 . 5) '(list-of fixnum))
    => T
    ```
    
    Further this can be used in type signatures
    
    ```cl
    (-> foo (fixnum) (list-of fixnum))
    (defun foo (x)
      (list x))
    ```


- [function] SYMBOL-TO-KEYWORD SYMBOL

    Turns a symbol into a keyword

- [macro] MUFFLE-PACKAGE-VARIANCE &REST PACKAGE-DECLARATIONS

    Muffle any errors about package variance and stating exports out of order.
    This is particularly an issue for SBCL as it will error when using MGL-PAX
    to do the export instead of DEFPACKAGE.
    
    This is more modular thank
    [MGL-PAX:DEFINE-PACKAGE](https://melisgl.Githubc.io/mgl-pax-world/mgl-pax-manual.html#MGL-PAX:DEFINE-PACKAGE%20MGL-PAX:MACRO)
    in that this can be used with any package creation function like
    [UIOP:DEFINE-PACKAGE](https://privet-kitty.github.io/etc/uiop.html#UIOP_002fPACKAGE).
    
    Here is an example usage:
    
    ```lisp
         (geb.utils:muffle-package-variance
           (uiop:define-package #:geb.lambda-conversion
             (:mix #:trivia #:geb #:serapeum #:common-lisp)
             (:export
              :compile-checked-term :stlc-ctx-to-mu)))
    ```


- [function] SUBCLASS-RESPONSIBILITY OBJ

    Denotes that the given method is the subclasses
    responsibility. Inspired from Smalltalk

- [macro] MAKE-PATTERN OBJECT-NAME &REST CONSTRUCTOR-NAMES

    make pattern matching position style instead of record style. This
    removes the record constructor style, however it can be brought back
    if wanted
    
    ```lisp
    (defclass alias (<substmorph> <substobj>)
      ((name :initarg :name
             :accessor name
             :type     symbol
             :documentation "The name of the GEB object")
       (obj :initarg :obj
            :accessor obj
            :documentation "The underlying geb object"))
      (:documentation "an alias for a geb object"))
    
    (make-pattern alias name obj)
    ```


### Accessors

These functions are generic lenses of the GEB codebase. If a class is
defined, where the names are not known, then these accessors are
likely to be used. They may even augment existing classes.

- [generic-function] MCAR OBJ

    Can be seen as calling CAR on a generic CLOS
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] MCADR OBJ

    like MCAR but for the CADR

- [generic-function] MCADDR OBJ

    like MCAR but for the CADDR

- [generic-function] MCADDDR OBJ

    like MCAR but for the CADDDR

- [generic-function] MCDR OBJ

    Similar to MCAR, however acts like a CDR for
    classes that we wish to view as a SEQUENCE

- [generic-function] OBJ OBJ

    Grabs the underlying
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] NAME OBJ

    the name of the given
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] FUNC OBJ

    the function of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] PREDICATE OBJ

    the PREDICATE of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] THEN OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] ELSE OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

## Testing

###### \[in package GEB-TEST\]
We use [parachute](https://quickref.common-lisp.net/parachute.html)
as our testing framework.

Please read the
[manual](https://quickref.common-lisp.net/parachute.html) for extra
features and how to better lay out future tests

- [function] RUN-TESTS &KEY (INTERACTIVE? NIL) (SUMMARY? NIL) (PLAIN? T) (DESIGNATORS '(GEB-TEST-SUITE))

    Here we run all the tests. We have many flags to determine how the
    tests ought to work
    
    ```lisp
    (run-tests :plain? nil :interactive? t) ==> 'interactive
    (run-tests :summary? t :interactive? t) ==> 'noisy-summary
    (run-tests :interactive? t)             ==> 'noisy-interactive
    (run-tests :summary? t)                 ==> 'summary
    (run-tests)                             ==> 'plain
    
    (run-tests :designators '(geb geb.lambda)) ==> run only those packages
    ```


- [function] CODE-COVERAGE &OPTIONAL (PATH NIL)

    generates code coverage, for CCL the coverage can be found at
    
    [CCL test coverage](../docs/tests/report.html)
    
    [SBCL test coverage](../docs/tests/cover-index.html)
    
    simply run this function to generate a fresh one

* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
